package main

import (
    "bytes"
    "fmt"
    "path/filepath"
    "strings"
    "unicode"

    "ariga.io/atlas/sql/schema"
    "golang.org/x/tools/imports"
)

type input struct {
	hclPath string
	outPath string
	pkg     string
	tag     string
	dialect string
	conf    Config
}

func generate(s schema.Schema, in input) ([]byte, error) {
	buf := new(bytes.Buffer)
	fmt.Fprintf(buf, "// Code generated by github.com/ucpr/atlas-hcl-gen-go. DO NOT EDIT.\n")
	fmt.Fprintf(buf, "// atlas-hcl-gen-go: %s\n", BuildVersion)
	fmt.Fprintf(buf, "// source: %s\n\n", in.hclPath)
	fmt.Fprintf(buf, "package %s\n\n", in.pkg)

	// Optionally emit named enum types and consts before structs.
	if strings.ToLower(in.conf.Enum) == "named" {
		type enumDef struct {
			typeName string
			values   []string
		}
		enums := make([]enumDef, 0)
		// Track seen to avoid duplicates in case of repeated columns with same name.
		seen := make(map[string]struct{})
		for i := range s.Tables {
			table := s.Tables[i]
			for j := range table.Columns {
				col := table.Columns[j]
				if col.Type == nil || col.Type.Type == nil {
					continue
				}
				if et, ok := col.Type.Type.(*schema.EnumType); ok {
					tn := enumTypeName(table.Name, col.Name)
					if _, ok := seen[tn]; ok {
						continue
					}
					seen[tn] = struct{}{}
					enums = append(enums, enumDef{typeName: tn, values: et.Values})
				}
			}
		}
		for _, e := range enums {
			fmt.Fprintf(buf, "type %s string\n\n", e.typeName)
			if len(e.values) > 0 {
				fmt.Fprintf(buf, "const (\n")
				used := map[string]struct{}{}
				for _, v := range e.values {
					cn := e.typeName + goIdentFromString(v)
					// ensure uniqueness
					base := cn
					k := 1
					for {
						if _, ok := used[cn]; !ok {
							break
						}
						k++
						cn = fmt.Sprintf("%s%d", base, k)
					}
					used[cn] = struct{}{}
					fmt.Fprintf(buf, "\t%s %s = \"%s\"\n", cn, e.typeName, v)
				}
				fmt.Fprintf(buf, ")\n\n")
			}
		}
	}

	for i := range s.Tables {
		table := s.Tables[i]
		fmt.Fprintf(buf, "type %s struct {\n", toCamelCase(table.Name))
		for j := range table.Columns {
			column := table.Columns[j]
			tp, err := goTypeForColumn(column, in.conf, in.dialect, table.Name)
			if err != nil {
				return nil, fmt.Errorf("%s.%s: %w", table.Name, column.Name, err)
			}
			fmt.Fprintf(buf, "\t%s\t%s\t`%s:\"%s\"`\n", toCamelCase(column.Name), tp, in.tag, column.Name)
		}
		fmt.Fprintf(buf, "}\n\n")
	}

	pb, err := imports.Process(in.outPath, buf.Bytes(), nil)
	if err != nil {
		return nil, fmt.Errorf("failed to format: %w", err)
	}

	return pb, nil
}

// generatePerTable generates a Go file per table and returns a map of
// absolute (or joined) file path to formatted file bytes.
func generatePerTable(s schema.Schema, in input, outDir string) (map[string][]byte, error) {
    files := make(map[string][]byte)

    // Pre-compute if enums are named to know whether to emit enum types per table.
    namedEnum := strings.ToLower(in.conf.Enum) == "named"

    for i := range s.Tables {
        table := s.Tables[i]

        buf := new(bytes.Buffer)
        fmt.Fprintf(buf, "// Code generated by github.com/ucpr/atlas-hcl-gen-go. DO NOT EDIT.\n")
        fmt.Fprintf(buf, "// atlas-hcl-gen-go: %s\n", BuildVersion)
        fmt.Fprintf(buf, "// source: %s\n\n", in.hclPath)
        fmt.Fprintf(buf, "package %s\n\n", in.pkg)

        // Table-local named enum types and consts (avoid duplicates by name within the table).
        if namedEnum {
            type enumDef struct {
                typeName string
                values   []string
            }
            enums := make([]enumDef, 0)
            seen := make(map[string]struct{})
            for j := range table.Columns {
                col := table.Columns[j]
                if col.Type == nil || col.Type.Type == nil {
                    continue
                }
                if et, ok := col.Type.Type.(*schema.EnumType); ok {
                    tn := enumTypeName(table.Name, col.Name)
                    if _, ok := seen[tn]; ok {
                        continue
                    }
                    seen[tn] = struct{}{}
                    enums = append(enums, enumDef{typeName: tn, values: et.Values})
                }
            }
            for _, e := range enums {
                fmt.Fprintf(buf, "type %s string\n\n", e.typeName)
                if len(e.values) > 0 {
                    fmt.Fprintf(buf, "const (\n")
                    used := map[string]struct{}{}
                    for _, v := range e.values {
                        cn := e.typeName + goIdentFromString(v)
                        // ensure uniqueness
                        base := cn
                        k := 1
                        for {
                            if _, ok := used[cn]; !ok {
                                break
                            }
                            k++
                            cn = fmt.Sprintf("%s%d", base, k)
                        }
                        used[cn] = struct{}{}
                        fmt.Fprintf(buf, "\t%s %s = \"%s\"\n", cn, e.typeName, v)
                    }
                    fmt.Fprintf(buf, ")\n\n")
                }
            }
        }

        // Struct definition for this table.
        fmt.Fprintf(buf, "type %s struct {\n", toCamelCase(table.Name))
        for j := range table.Columns {
            column := table.Columns[j]
            tp, err := goTypeForColumn(column, in.conf, in.dialect, table.Name)
            if err != nil {
                return nil, fmt.Errorf("%s.%s: %w", table.Name, column.Name, err)
            }
            fmt.Fprintf(buf, "\t%s\t%s\t`%s:\"%s\"`\n", toCamelCase(column.Name), tp, in.tag, column.Name)
        }
        fmt.Fprintf(buf, "}\n\n")

        // File name: <snake_case(table)>.go under outDir
        base := snakeFromCamel(toCamelCase(table.Name)) + ".go"
        fp := filepath.Join(outDir, base)
        pb, err := imports.Process(fp, buf.Bytes(), nil)
        if err != nil {
            return nil, fmt.Errorf("failed to format %s: %w", base, err)
        }
        files[fp] = pb
    }

    return files, nil
}

func toCamelCase(s string) string {
	if s == "" {
		return ""
	}
	// Known Go acronyms that should remain uppercased.
	// Compare case-insensitively per token.
	acronyms := map[string]struct{}{
		"ID": {}, "URL": {}, "UUID": {}, "JSON": {}, "SQL": {},
		"HTTP": {}, "API": {}, "IP": {}, "HTML": {}, "XML": {},
	}

	// Tokenize by non-alphanumeric characters.
	var tokens []string
	var cur []rune
	for _, r := range s {
		if unicode.IsLetter(r) || unicode.IsDigit(r) {
			cur = append(cur, r)
			continue
		}
		if len(cur) > 0 {
			tokens = append(tokens, string(cur))
			cur = cur[:0]
		}
	}
	if len(cur) > 0 {
		tokens = append(tokens, string(cur))
	}

	// Build CamelCase preserving digits and uppercasing acronyms.
	var out strings.Builder
	for _, tok := range tokens {
		if tok == "" {
			continue
		}
		upper := strings.ToUpper(tok)
		if _, ok := acronyms[upper]; ok {
			out.WriteString(upper)
			continue
		}
		// If token already contains an uppercase letter after the first rune,
		// treat it as CamelCase and only ensure the first rune is uppercase.
		hasUpperAfterFirst := false
		for _, r := range tok[1:] {
			if unicode.IsUpper(r) {
				hasUpperAfterFirst = true
				break
			}
		}
		if hasUpperAfterFirst {
			r := []rune(tok)
			if len(r) > 0 && unicode.IsLetter(r[0]) {
				r[0] = unicode.ToUpper(r[0])
			}
			out.WriteString(string(r))
			continue
		}
		// Normal word: lower + capitalize first letter only (keep digits as-is).
		lower := strings.ToLower(tok)
		r := []rune(lower)
		if len(r) == 0 {
			continue
		}
		if unicode.IsLetter(r[0]) {
			r[0] = unicode.ToUpper(r[0])
		}
		out.WriteString(string(r))
	}

	res := out.String()
	if res == "" {
		return ""
	}
	// Identifier cannot start with a digit in Go; prefix with 'N' if so.
	if res[0] >= '0' && res[0] <= '9' {
		res = "N" + res
	}
	return res
}

// enumTypeName returns a Go type name for an enum column based on table and column names.
func enumTypeName(tableName, columnName string) string {
    return toCamelCase(tableName) + toCamelCase(columnName)
}

// goIdentFromString converts an arbitrary string into a valid Go identifier chunk.
func goIdentFromString(s string) string {
	if s == "" {
		return "Empty"
	}
	// Build a CamelCase identifier preserving digits.
	var out strings.Builder
	upperNext := true
	for _, r := range s {
		isLetter := (r >= 'A' && r <= 'Z') || (r >= 'a' && r <= 'z')
		isDigit := r >= '0' && r <= '9'
		if isLetter || isDigit {
			if upperNext && isLetter {
				if r >= 'a' && r <= 'z' {
					r = r - 'a' + 'A'
				}
				out.WriteRune(r)
				upperNext = false
				continue
			}
			out.WriteRune(r)
			upperNext = false
			continue
		}
		// separator encountered
		upperNext = true
	}
	res := out.String()
	if res == "" {
		res = "Empty"
	}
	// Identifier cannot start with digit
	if res[0] >= '0' && res[0] <= '9' {
		res = "N" + res
	}
	return res
}

// snakeFromCamel converts a CamelCase identifier into lower_snake_case.
// Digits are preserved and considered word boundaries.
func snakeFromCamel(s string) string {
    if s == "" {
        return ""
    }
    var b strings.Builder
    prevLowerOrDigit := false
    for i, r := range s {
        if i == 0 {
            b.WriteRune(unicode.ToLower(r))
            prevLowerOrDigit = unicode.IsLower(r) || unicode.IsDigit(r)
            continue
        }
        if unicode.IsUpper(r) {
            if prevLowerOrDigit {
                b.WriteByte('_')
            }
            b.WriteRune(unicode.ToLower(r))
            prevLowerOrDigit = false
            continue
        }
        if unicode.IsDigit(r) {
            if !prevLowerOrDigit && b.Len() > 0 {
                b.WriteByte('_')
            }
            b.WriteRune(r)
            prevLowerOrDigit = true
            continue
        }
        // lower or other letters become lower
        if r == ' ' || r == '-' {
            b.WriteByte('_')
            prevLowerOrDigit = false
            continue
        }
        b.WriteRune(unicode.ToLower(r))
        prevLowerOrDigit = true
    }
    return b.String()
}
